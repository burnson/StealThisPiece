<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Steal This Piece</title>
    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Inconsolata">
    <style>
      body {
        font-family: 'Inconsolata', serif;
        font-size: 48px;
      }
    </style>
  </head>
  <body>
    <div>Steal This Piece!</div>
<script type="text/javascript" src="http://reverbjs.org/reverb.min.js">
</script>
<script type="text/javascript">
/*include:index-instruments.js*/
/*include:index-stp.js*/

var context = new (window.AudioContext || window.webkitAudioContext)();
reverbjs.extend(context);
var midiQueue;
var playerStartTime;
var timeInAdvanceToSchedule = 0.5;
var predestination = context.destination;
var reverbGain;
var masterGain;
var reverb;

function configureReverb () {
  masterGain = context.createGain();
  masterGain.gain.value = 1.0;
  masterGain.connect(context.destination);

  reverbGain = context.createGain();
  reverbGain.gain.value = 3.0;
  reverbGain.connect(masterGain);
  
  predestination = reverbGain;

  reverb = context.createReverbFromUrl(
    'http://reverbjs.org/Library/UndergroundCarPark.wav',
    function() { console.log('Loaded reverb'); });
  reverbGain.connect(reverb);
  reverb.connect(masterGain);
}

function dBToGain(dB) {
  if (dB <= -100) {
    return 0;
  }
  return Math.pow(10, dB / 10);
}

function frequencyToMIDINoteNumber (frequency) {
  var n = 12 * Math.log(frequency * Math.pow(2, 11 / 4) / 55) / Math.log(2);
  var rounded = Math.round(n * 128) / 128;
  return rounded;
}

function getCurrentTime() {
  return context.currentTime;
}

function getPieceAsMIDI() {
  createPiece();
  exampleData = pieceAsMIDI();
  var csv = pieceAsCSV();
  var csvMD5 = md5(csv);
  if (csvMD5 !== '0ca494dc0a5994afc36e3529d7059f6a') {
    alert('Warning: piece has changed!');
  }
  console.log('Hash of CSV: ' + csvMD5);

  var sortKey = "time";
  exampleData.sort(function(a, b) {
    if (a[sortKey] < b[sortKey]) {
      return -1;
    } else if (a[sortKey] > b[sortKey]) {
      return 1;
    }
    return 0;
  });
  return exampleData;
}

function initialize () {
  configureReverb();
  schedulePiece();
}

function midiNoteNumberToFrequency (midiNoteNumber) {
  return 55 * Math.pow(2, (midiNoteNumber - 33) / 12);
}

function processNextFrame () {
  if (midiQueue.length === 0) {
    return;
  }
  var playerCurrentTime = getCurrentTime() - playerStartTime;
  var playerScheduleTime = playerCurrentTime + timeInAdvanceToSchedule;
  while (midiQueue[0] !== undefined && midiQueue[0].time < playerScheduleTime) {
    var m = midiQueue.shift();
    scheduleInstrumentalNote(m.channel, m.pitch, m.time + playerStartTime,
      m.duration, m.velocity);
  }
  window.requestAnimationFrame(processNextFrame);
}

function scheduleInstrumentalNote (instrument, midiNoteNumber, startTime,
  duration, velocity) {
  if (velocity === undefined) {
    velocity = 0.5;
  } else {
    velocity = Math.min(Math.max(velocity / 127, 0.01), 1);
  }
  var gain = 0.1 * velocity;
  var instruments = [
    scheduleFluteNote,
    scheduleOboeNote,
    scheduleClarinetNote,
    scheduleBassoonNote,
    scheduleHornNote,
    scheduleTrumpetNote,
    scheduleTromboneNote,
    scheduleBaritoneSaxNote,
    scheduleVibraphoneNote,
    scheduleCrotalesNote,
    scheduleViolinNote,
    scheduleViolaNote,
    scheduleCelloNote,
    scheduleDoubleBassNote
  ];
  instruments[instrument](midiNoteNumber, startTime, duration, gain);
}

function schedulePiece () {
  scheduleInstrumentalNote(0, 60, 0, 0, 0); //just to get things going
  midiQueue = getPieceAsMIDI();
  playerStartTime = getCurrentTime() + 1.0;
  processNextFrame();
}

function scheduleOscillator(type, note, startTime, duration, gain, shape) {
  if (startTime < getCurrentTime()) {
    console.log('Warning: dropped note that started in past');
    return;
  }
  var gainShaper = context.createGain();
  gainShaper.gain.value = 0;
  gainShaper.gain.setValueAtTime(0, startTime);
  for (var i in shape) {
    var g = dBToGain(shape[i].dB) * gain;
    var t = startTime + shape[i].time * duration;
    gainShaper.gain.linearRampToValueAtTime(g, t);
  }
  gainShaper.connect(predestination);
  
  var oscillator = context.createOscillator();
  oscillator.type = type;
  oscillator.frequency.value = midiNoteNumberToFrequency(note);
  oscillator.start(startTime);
  oscillator.stop(startTime + duration);
  oscillator.connect(gainShaper);
}

function shutdownGracefully() {
  console.log('Shutting down audio...');
  var start = getCurrentTime(), length = 0.5, progress = 0;
  while (progress <= 1) {
    masterGain.gain.value = 1 - progress;
    progress = (getCurrentTime() - start) / length;
  }
}

window.onload = initialize;
window.onbeforeunload = shutdownGracefully;
        </script>
    </body>
</html>